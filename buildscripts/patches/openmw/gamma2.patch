diff --git a/apps/openmw/mwrender/renderingmanager.cpp b/apps/openmw/mwrender/renderingmanager.cpp
index a634bdd29..65c907641 100644
--- a/apps/openmw/mwrender/renderingmanager.cpp
+++ b/apps/openmw/mwrender/renderingmanager.cpp
@@ -71,6 +71,32 @@
 #include "screenshotmanager.hpp"
 #include "postprocessor.hpp"
 
+namespace {
+    class GammaCorrection : public osg::StateAttribute
+    {
+        public :
+            GammaCorrection() : gamma(0) {}
+            GammaCorrection(float gamma_) : gamma(gamma_) {}
+            GammaCorrection(const GammaCorrection& copy,const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY)
+                : osg::StateAttribute(copy,copyop), gamma(copy.gamma) {}
+
+            META_StateAttribute(, GammaCorrection, (osg::StateAttribute::Type)123)
+
+            /** Return -1 if *this < *rhs, 0 if *this==*rhs, 1 if *this>*rhs. */
+            virtual int compare(const StateAttribute& sa) const
+            {
+                throw std::runtime_error("");
+            }
+
+            virtual void apply(osg::State& state) const {
+                glLightModelfv(0x4242,&gamma);
+            }
+
+        private:
+            float gamma;
+    };
+}
+
 namespace MWRender
 {
     class GroundcoverUpdater : public SceneUtil::StateSetUpdater
@@ -208,6 +234,18 @@ namespace MWRender
             }
             else
                 stateset->removeAttribute(osg::StateAttribute::POLYGONMODE);
+            {
+                static bool init = false;
+                static float gamma = 0;
+                if (!init) {
+                    const char *s = getenv("OPENMW_GAMMA");
+                    if (s)
+                        gamma = atof(s);
+                    init = true;
+                }
+                osg::ref_ptr<GammaCorrection> gammaAttribute = new GammaCorrection(gamma);
+                stateset->setAttribute(gammaAttribute);
+            }
         }
 
         void apply(osg::StateSet* stateset, osg::NodeVisitor*) override
@@ -373,6 +411,10 @@ namespace MWRender
         for (auto itr = shadowDefines.begin(); itr != shadowDefines.end(); itr++)
             globalDefines[itr->first] = itr->second;
 
+        const char *s = getenv("OPENMW_GAMMA");
+        if (s) globalDefines["gamma"] = s;
+            else globalDefines["gamma"] = "1.0";
+
         globalDefines["forcePPL"] = Settings::Manager::getBool("force per pixel lighting", "Shaders") ? "1" : "0";
         globalDefines["clamp"] = Settings::Manager::getBool("clamp lighting", "Shaders") ? "1" : "0";
         globalDefines["preLightEnv"] = Settings::Manager::getBool("apply lighting to environment maps", "Shaders") ? "1" : "0";
@@ -512,6 +554,9 @@ namespace MWRender
 
         mScreenshotManager.reset(new ScreenshotManager(viewer, mRootNode, sceneRoot, mResourceSystem, mWater.get()));
 
+        osg::ref_ptr<GammaCorrection> gamma = new GammaCorrection(1.0);
+        mViewer->getCamera()->getOrCreateStateSet()->setAttribute(gamma);
+
         mViewer->setLightingMode(osgViewer::View::NO_LIGHT);
 
         osg::ref_ptr<osg::LightSource> source = new osg::LightSource;
diff --git a/files/shaders/groundcover_fragment.glsl b/files/shaders/groundcover_fragment.glsl
index e4a18b9e8..17f5a2941 100755
--- a/files/shaders/groundcover_fragment.glsl
+++ b/files/shaders/groundcover_fragment.glsl
@@ -78,4 +78,6 @@ gl_FragData[0].xyz *= lighting;
 
     gl_FragData[0].xyz = mix(gl_FragData[0].xyz, gl_Fog.color.xyz, fogValue);
 
+    gl_FragData[0].xyz = pow(gl_FragData[0].xyz, vec3(1.0/@gamma));
+
 }
diff --git a/files/shaders/objects_fragment.glsl b/files/shaders/objects_fragment.glsl
index d304b2abe..0b7273388 100644
--- a/files/shaders/objects_fragment.glsl
+++ b/files/shaders/objects_fragment.glsl
@@ -227,4 +227,6 @@ void main()
 #endif
 
     applyShadowDebugOverlay();
+
+    gl_FragData[0].xyz = pow(gl_FragData[0].xyz, vec3(1.0/@gamma));
 }
diff --git a/files/shaders/particles_fragment.glsl b/files/shaders/particles_fragment.glsl
index d304b2abe..0b7273388 100644
--- a/files/shaders/particles_fragment.glsl
+++ b/files/shaders/particles_fragment.glsl
@@ -227,4 +227,6 @@ void main()
 #endif
 
     applyShadowDebugOverlay();
+
+    gl_FragData[0].xyz = pow(gl_FragData[0].xyz, vec3(1.0/@gamma));
 }
diff --git a/files/shaders/pbr/groundcover_fragment.glsl b/files/shaders/pbr/groundcover_fragment.glsl
index fb98ee02c..0ab504e3b 100755
--- a/files/shaders/pbr/groundcover_fragment.glsl
+++ b/files/shaders/pbr/groundcover_fragment.glsl
@@ -97,4 +97,5 @@ gl_FragData[0].xyz *= lighting;
 
     gl_FragData[0].xyz = mix(gl_FragData[0].xyz, gl_Fog.color.xyz, fogValue);
 
+    gl_FragData[0].xyz = pow(gl_FragData[0].xyz, vec3(1.0/@gamma));
 }
diff --git a/files/shaders/pbr/objects_fragment.glsl b/files/shaders/pbr/objects_fragment.glsl
index d7d5fc61c..5ef33344d 100755
--- a/files/shaders/pbr/objects_fragment.glsl
+++ b/files/shaders/pbr/objects_fragment.glsl
@@ -289,4 +289,6 @@ void main()
 	#endif
 
     applyShadowDebugOverlay();
+
+    gl_FragData[0].xyz = pow(gl_FragData[0].xyz, vec3(1.0/@gamma));
 }
diff --git a/files/shaders/pbr/particles_fragment.glsl b/files/shaders/pbr/particles_fragment.glsl
index d7d5fc61c..5ef33344d 100755
--- a/files/shaders/pbr/particles_fragment.glsl
+++ b/files/shaders/pbr/particles_fragment.glsl
@@ -289,4 +289,6 @@ void main()
 	#endif
 
     applyShadowDebugOverlay();
+
+    gl_FragData[0].xyz = pow(gl_FragData[0].xyz, vec3(1.0/@gamma));
 }
diff --git a/files/shaders/pbr/pbr readme.txt b/files/shaders/pbr/pbr readme.txt
deleted file mode 100755
index 42175ae74..000000000
--- a/files/shaders/pbr/pbr readme.txt	
+++ /dev/null
@@ -1,24 +0,0 @@
-OpenMW PBR shaders v04 ALPHA
-Now it can render non metals without ambient reflections.
-metals and reflections after sky and post process shaders.
-
-_spec as PBR map
-means, delete all your old spec maps!!!
-
-_spec channels
-R: metalness 1.0(255) is metal
-G: roughness
-B: specular, 0.5 for 0.04(conversion is 0.16 * x^2)
-A: AO (don't have black alpha)
-
-Terrain doesn't have spec,
-instead you can put roughness into alpha of _diffusespec
-we assume there is no metal ground.
-
-MGE XE conversion
-_normals to _n
-invert G channel(openmw is DX style, MGE is OpenGL style. Yes, I know!)
-
-_parameters to _spec
-invert R channel
-make sure your alpha is not black as it is used for AO.
diff --git a/files/shaders/pbr/terrain_fragment.glsl b/files/shaders/pbr/terrain_fragment.glsl
index 29830c900..9b75cbba4 100755
--- a/files/shaders/pbr/terrain_fragment.glsl
+++ b/files/shaders/pbr/terrain_fragment.glsl
@@ -161,4 +161,6 @@ void main()
 	gl_FragData[0].xyz = mix(gl_FragData[0].xyz, gl_Fog.color.xyz, fogValue);
 
     applyShadowDebugOverlay();
+
+    gl_FragData[0].xyz = pow(gl_FragData[0].xyz, vec3(1.0/@gamma));
 }
diff --git a/files/shaders/pbr/water_fragment.glsl b/files/shaders/pbr/water_fragment.glsl
index 8107fa33f..50f09a851 100755
--- a/files/shaders/pbr/water_fragment.glsl
+++ b/files/shaders/pbr/water_fragment.glsl
@@ -292,4 +292,6 @@ void main(void)
     gl_FragData[0].xyz = mix(gl_FragData[0].xyz,  gl_Fog.color.xyz,  fogValue);
 
     applyShadowDebugOverlay();
+
+    gl_FragData[0].xyz = pow(gl_FragData[0].xyz, vec3(1.0/@gamma));
 }
diff --git a/files/shaders/terrain_fragment.glsl b/files/shaders/terrain_fragment.glsl
index d9d4a6dc3..dd29aa304 100644
--- a/files/shaders/terrain_fragment.glsl
+++ b/files/shaders/terrain_fragment.glsl
@@ -116,4 +116,6 @@ void main()
     gl_FragData[0].xyz = mix(gl_FragData[0].xyz, gl_Fog.color.xyz, fogValue);
 
     applyShadowDebugOverlay();
+
+    gl_FragData[0].xyz = pow(gl_FragData[0].xyz, vec3(1.0/@gamma));
 }
diff --git a/files/shaders/water_fragment.glsl b/files/shaders/water_fragment.glsl
index b40d9004f..fc56d3e2a 100644
--- a/files/shaders/water_fragment.glsl
+++ b/files/shaders/water_fragment.glsl
@@ -291,4 +291,6 @@ void main(void)
     gl_FragData[0].xyz = mix(gl_FragData[0].xyz,  gl_Fog.color.xyz,  fogValue);
 
     applyShadowDebugOverlay();
+
+    gl_FragData[0].xyz = pow(gl_FragData[0].xyz, vec3(1.0/@gamma));
 }
