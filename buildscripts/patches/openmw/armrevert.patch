diff --git a/apps/openmw/mwworld/cellref.cpp b/apps/openmw/mwworld/cellref.cpp
index 2f4702b1e..0b1696404 100644
--- a/apps/openmw/mwworld/cellref.cpp
+++ b/apps/openmw/mwworld/cellref.cpp
@@ -8,6 +8,11 @@
 namespace MWWorld
 {
 
+    const ESM::RefNum& CellRef::getRefNum() const
+    {
+        return mCellRef.mRefNum;
+    }
+
     const ESM::RefNum& CellRef::getOrAssignRefNum(ESM::RefNum& lastAssignedRefNum)
     {
         if (!mCellRef.mRefNum.isSet())
@@ -28,11 +33,41 @@ namespace MWWorld
         return mCellRef.mRefNum;
     }
 
+    bool CellRef::hasContentFile() const
+    {
+        return mCellRef.mRefNum.hasContentFile();
+    }
+
     void CellRef::unsetRefNum()
     {
         mCellRef.mRefNum.unset();
     }
 
+    std::string CellRef::getRefId() const
+    {
+        return mCellRef.mRefID;
+    }
+
+    bool CellRef::getTeleport() const
+    {
+        return mCellRef.mTeleport;
+    }
+
+    ESM::Position CellRef::getDoorDest() const
+    {
+        return mCellRef.mDoorDest;
+    }
+
+    std::string CellRef::getDestCell() const
+    {
+        return mCellRef.mDestCell;
+    }
+
+    float CellRef::getScale() const
+    {
+        return mCellRef.mScale;
+    }
+
     void CellRef::setScale(float scale)
     {
         if (scale != mCellRef.mScale)
@@ -42,12 +77,22 @@ namespace MWWorld
         }
     }
 
+    ESM::Position CellRef::getPosition() const
+    {
+        return mCellRef.mPos;
+    }
+
     void CellRef::setPosition(const ESM::Position &position)
     {
         mChanged = true;
         mCellRef.mPos = position;
     }
 
+    float CellRef::getEnchantmentCharge() const
+    {
+        return mCellRef.mEnchantmentCharge;
+    }
+
     float CellRef::getNormalizedEnchantmentCharge(int maxCharge) const
     {
         if (maxCharge == 0)
@@ -73,6 +118,11 @@ namespace MWWorld
         }
     }
 
+    int CellRef::getCharge() const
+    {
+        return mCellRef.mChargeInt;
+    }
+
     void CellRef::setCharge(int charge)
     {
         if (charge != mCellRef.mChargeInt)
@@ -100,6 +150,11 @@ namespace MWWorld
         }
     }
 
+    float CellRef::getChargeFloat() const
+    {
+        return mCellRef.mChargeFloat;
+    }
+
     void CellRef::setChargeFloat(float charge)
     {
         if (charge != mCellRef.mChargeFloat)
@@ -109,6 +164,16 @@ namespace MWWorld
         }
     }
 
+    std::string CellRef::getOwner() const
+    {
+        return mCellRef.mOwner;
+    }
+
+    std::string CellRef::getGlobalVariable() const
+    {
+        return mCellRef.mGlobalVariable;
+    }
+
     void CellRef::resetGlobalVariable()
     {
         if (!mCellRef.mGlobalVariable.empty())
@@ -127,6 +192,11 @@ namespace MWWorld
         }
     }
 
+    int CellRef::getFactionRank() const
+    {
+        return mCellRef.mFactionRank;
+    }
+
     void CellRef::setOwner(const std::string &owner)
     {
         if (owner != mCellRef.mOwner)
@@ -136,6 +206,11 @@ namespace MWWorld
         }
     }
 
+    std::string CellRef::getSoul() const
+    {
+        return mCellRef.mSoul;
+    }
+
     void CellRef::setSoul(const std::string &soul)
     {
         if (soul != mCellRef.mSoul)
@@ -145,6 +220,11 @@ namespace MWWorld
         }
     }
 
+    std::string CellRef::getFaction() const
+    {
+        return mCellRef.mFaction;
+    }
+
     void CellRef::setFaction(const std::string &faction)
     {
         if (faction != mCellRef.mFaction)
@@ -154,6 +234,11 @@ namespace MWWorld
         }
     }
 
+    int CellRef::getLockLevel() const
+    {
+        return mCellRef.mLockLevel;
+    }
+
     void CellRef::setLockLevel(int lockLevel)
     {
         if (lockLevel != mCellRef.mLockLevel)
@@ -176,6 +261,16 @@ namespace MWWorld
         setLockLevel(-abs(mCellRef.mLockLevel)); //Makes lockLevel negative
     }
 
+    std::string CellRef::getKey() const
+    {
+        return mCellRef.mKey;
+    }
+
+    std::string CellRef::getTrap() const
+    {
+        return mCellRef.mTrap;
+    }
+
     void CellRef::setTrap(const std::string& trap)
     {
         if (trap != mCellRef.mTrap)
@@ -185,6 +280,11 @@ namespace MWWorld
         }
     }
 
+    int CellRef::getGoldValue() const
+    {
+        return mCellRef.mGoldValue;
+    }
+
     void CellRef::setGoldValue(int value)
     {
         if (value != mCellRef.mGoldValue)
@@ -199,4 +299,9 @@ namespace MWWorld
         state.mRef = mCellRef;
     }
 
+    bool CellRef::hasChanged() const
+    {
+        return mChanged;
+    }
+
 }
diff --git a/apps/openmw/mwworld/cellref.hpp b/apps/openmw/mwworld/cellref.hpp
index b5e80930e..78170a766 100644
--- a/apps/openmw/mwworld/cellref.hpp
+++ b/apps/openmw/mwworld/cellref.hpp
@@ -23,7 +23,7 @@ namespace MWWorld
         }
 
         // Note: Currently unused for items in containers
-        const ESM::RefNum& getRefNum() const { return mCellRef.mRefNum; }
+        const ESM::RefNum& getRefNum() const;
 
         // Returns RefNum.
         // If RefNum is not set, assigns a generated one and changes the "lastAssignedRefNum" counter.
@@ -33,35 +33,35 @@ namespace MWWorld
         void unsetRefNum();
 
         /// Does the RefNum have a content file?
-        bool hasContentFile() const { return mCellRef.mRefNum.hasContentFile(); }
+        bool hasContentFile() const;
 
         // Id of object being referenced
-        const std::string& getRefId() const { return mCellRef.mRefID; }
+        std::string getRefId() const;
 
         // Reference to ID of the object being referenced
-        const std::string& getRefIdRef() const { return mCellRef.mRefID; }  // TODO replace with getRefId
+        const std::string& getRefIdRef() const { return mCellRef.mRefID; }
 
         // For doors - true if this door teleports to somewhere else, false
         // if it should open through animation.
-        bool getTeleport() const { return mCellRef.mTeleport; }
+        bool getTeleport() const;
 
         // Teleport location for the door, if this is a teleporting door.
-        const ESM::Position& getDoorDest() const { return mCellRef.mDoorDest; }
+        ESM::Position getDoorDest() const;
 
         // Destination cell for doors (optional)
-        const std::string& getDestCell() const { return mCellRef.mDestCell; }
+        std::string getDestCell() const;
 
         // Scale applied to mesh
-        float getScale() const { return mCellRef.mScale; }
+        float getScale() const;
         void setScale(float scale);
 
         // The *original* position and rotation as it was given in the Construction Set.
         // Current position and rotation of the object is stored in RefData.
-        const ESM::Position& getPosition() const { return mCellRef.mPos; }
+        ESM::Position getPosition() const;
         void setPosition (const ESM::Position& position);
 
         // Remaining enchantment charge. This could be -1 if the charge was not touched yet (i.e. full).
-        float getEnchantmentCharge() const { return mCellRef.mEnchantmentCharge; }
+        float getEnchantmentCharge() const;
 
         // Remaining enchantment charge rescaled to the supplied maximum charge (such as one of the enchantment).
         float getNormalizedEnchantmentCharge(int maxCharge) const;
@@ -71,57 +71,57 @@ namespace MWWorld
         // For weapon or armor, this is the remaining item health.
         // For tools (lockpicks, probes, repair hammer) it is the remaining uses.
         // If this returns int(-1) it means full health.
-        int getCharge() const { return mCellRef.mChargeInt; }
-        float getChargeFloat() const { return mCellRef.mChargeFloat; } // Implemented as union with int charge
+        int getCharge() const;
+        float getChargeFloat() const; // Implemented as union with int charge
         void setCharge(int charge);
         void setChargeFloat(float charge);
         void applyChargeRemainderToBeSubtracted(float chargeRemainder); // Stores remainders and applies if > 1
 
         // The NPC that owns this object (and will get angry if you steal it)
-        const std::string& getOwner() const { return mCellRef.mOwner; }
+        std::string getOwner() const;
         void setOwner(const std::string& owner);
 
         // Name of a global variable. If the global variable is set to '1', using the object is temporarily allowed
         // even if it has an Owner field.
         // Used by bed rent scripts to allow the player to use the bed for the duration of the rent.
-        const std::string& getGlobalVariable() const { return mCellRef.mGlobalVariable; }
+        std::string getGlobalVariable() const;
 
         void resetGlobalVariable();
 
         // ID of creature trapped in this soul gem
-        const std::string& getSoul() const { return mCellRef.mSoul; }
+        std::string getSoul() const;
         void setSoul(const std::string& soul);
 
         // The faction that owns this object (and will get angry if
         // you take it and are not a faction member)
-        const std::string& getFaction() const { return mCellRef.mFaction; }
+        std::string getFaction() const;
         void setFaction (const std::string& faction);
 
         // PC faction rank required to use the item. Sometimes is -1, which means "any rank".
         void setFactionRank(int factionRank);
-        int getFactionRank() const { return mCellRef.mFactionRank; }
+        int getFactionRank() const;
 
         // Lock level for doors and containers
         // Positive for a locked door. 0 for a door that was never locked.
         // For an unlocked door, it is set to -(previous locklevel)
-        int getLockLevel() const { return mCellRef.mLockLevel; }
+        int getLockLevel() const;
         void setLockLevel(int lockLevel);
         void lock(int lockLevel);
         void unlock();
          // Key and trap ID names, if any
-        const std::string& getKey() const { return mCellRef.mKey; }
-        const std::string& getTrap() const { return mCellRef.mTrap; }
+        std::string getKey() const;
+        std::string getTrap() const;
         void setTrap(const std::string& trap);
 
         // This is 5 for Gold_005 references, 100 for Gold_100 and so on.
-        int getGoldValue() const { return mCellRef.mGoldValue; }
+        int getGoldValue() const;
         void setGoldValue(int value);
 
         // Write the content of this CellRef into the given ObjectState
         void writeState (ESM::ObjectState& state) const;
 
         // Has this CellRef changed since it was originally loaded?
-        bool hasChanged() const { return mChanged; }
+        bool hasChanged() const;
 
     private:
         bool mChanged;
